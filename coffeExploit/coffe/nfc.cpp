#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nfc.hpp"

uint8_t Nfc::keys[] = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xd3, 0xf7, 0xd3, 0xf7, 0xd3, 0xf7,
	0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5,
	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5,
	0x4d, 0x3a, 0x99, 0xc3, 0x51, 0xdd,
	0x1a, 0x98, 0x2c, 0x7e, 0x45, 0x9a,
	0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xab, 0xcd, 0xef, 0x12, 0x34, 0x56
};

const nfc_modulation Nfc::nmMifare = { NMT_ISO14443A, NBR_106 };

Nfc::Nfc() {
	nfc_init(NULL);
	// Display libnfc version
	const char *acLibnfcVersion = nfc_version();
	printf("uses libnfc %s\n", acLibnfcVersion);
	// Open, using the first available NFC device
	pnd = nfc_open(NULL, NULL);
	if (pnd == NULL) {
		fprintf(stderr, "Unable to open NFC device.");
		exit(EXIT_FAILURE);
	}
	// Set opened NFC device to initiator mode
	if (nfc_initiator_init(pnd) < 0) {
		nfc_perror(pnd, "nfc_initiator_init");
		exit(EXIT_FAILURE);
	}
	printf("NFC reader: %s opened\n", nfc_device_get_name(pnd));
	// Poll for a ISO14443A (MIFARE) tag
	if (nfc_initiator_select_passive_target(pnd, nmMifare, NULL, 0, &nt) > 0) {
		printf("The following (NFC) ISO14443A tag was found:\n");
		printf("    ATQA (SENS_RES): ");
		print_hex(nt.nti.nai.abtAtqa, 2);
		printf("       UID (NFCID%c): ", (nt.nti.nai.abtUid[0] == 0x08 ? '3' : '1'));
		print_hex(nt.nti.nai.abtUid, nt.nti.nai.szUidLen);
		printf("      SAK (SEL_RES): ");
		print_hex(&nt.nti.nai.btSak, 1);
		if (nt.nti.nai.szAtsLen) {
			printf("          ATS (ATR): ");
			print_hex(nt.nti.nai.abtAts, nt.nti.nai.szAtsLen);
		}
	}
}

Nfc::~Nfc() {
	// Close NFC device
	nfc_close(pnd);
	nfc_exit(NULL);
}

bool Nfc::read(int block, uint8_t* data) {
	if (nfc_initiator_mifare_cmd(pnd, MC_READ, block, &mp)) {
		memcpy(data, mp.mpd.abtData, 16);
		return true;
	} else {
		fprintf(stderr, "Error: unable to read block 0x%02x\n", block);
		return false;
	}
}

bool Nfc::write(int block, uint8_t* data) {
	memcpy(mp.mpd.abtData, data, 16);
	if (nfc_initiator_mifare_cmd(pnd, MC_WRITE, block, &mp)) {
		return true;
	} else {
		fprintf(stderr, "Error: unable to read block 0x%02x\n", block);
		return false;
	}
}

void Nfc::initValue(int sector, int block, int value) {
}

int Nfc::readValue(int sector, int block) {
}

int Nfc::incValue(int sector, int block, int value) {
}

int Nfc::decValue(int sector, int block, int value) {
}

bool Nfc::is_trailer_block(uint32_t uiBlock) {
	// Test if we are in the small or big sectors
	if (uiBlock < 128)
		return ((uiBlock + 1) % 4 == 0);
	else
		return ((uiBlock + 1) % 16 == 0);
}

uint32_t Nfc::get_trailer_block(uint32_t uiFirstBlock) {
	// Test if we are in the small or big sectors
	uint32_t trailer_block = 0;
	if (uiFirstBlock < 128) {
		trailer_block = uiFirstBlock + (3 - (uiFirstBlock % 4));
	} else {
		trailer_block = uiFirstBlock + (15 - (uiFirstBlock % 16));
	}
	return trailer_block;
}

bool Nfc::authenticate(int block, uint8_t* key, char keyType) {
	mifare_cmd mc;
	// Set the authentication information (uid)
	memcpy(mp.mpa.abtAuthUid, nt.nti.nai.abtUid + nt.nti.nai.szUidLen - 4, 4);
	// Should we use key A or B?
	if(keyType == 'A') {
		mc = MC_AUTH_A;
		memcpy(mp.mpa.abtKey, key, 6);
	} else if (keyType == 'B') {
		memcpy(mp.mpa.abtKey, key, 6);
		mc = MC_AUTH_B;
	} else {
		return false;
	}
	// Try to authenticate for the current sector
	if (nfc_initiator_mifare_cmd(pnd, mc, block, &mp))
		return true;
	nfc_initiator_select_passive_target(pnd, nmMifare, nt.nti.nai.abtUid, nt.nti.nai.szUidLen, NULL);
	return false;
}


void Nfc::print_hex(const uint8_t *pbtData, const size_t szBytes) {
	size_t  szPos;
	for (szPos = 0; szPos < szBytes; szPos++) {
		printf("%02x  ", pbtData[szPos]);
	}
	printf("\n");
}

void Nfc::dump() {
	 uint8_t keyB[6] = {0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5};
    
    for(uint8_t block = 63; block >= 0; block--){
        if(is_trailer_block(block)){
            bool success = authenticate(block, keyB, 'B');
            fprintf(stderr,"Authenticate block %d with key %c -> %d\n", block, 'B', success);
            if(success){
				uint8_t data[16];
				if(read(block, data)){
					fprintf(stderr,"read block %d : ", block);
					for(uint8_t d = 0; d < 16; d++){
						fprintf(stderr,"0x%x ", data[d]);
					}
				}
				fprintf(stderr,"\n");
            }else{
                // When a failure occured we need to redo the anti-collision
                if (nfc_initiator_select_passive_target(pnd, nmMifare, NULL, 0, &nt) < 0) {
					printf("!\nError: tag was removed\n");
					return;
                }
            }
        }else{
			uint8_t data[16];
			if(read(block, data)){
				fprintf(stderr,"read block %d : ", block);
				for(uint8_t d = 0; d < 16; d++){
					fprintf(stderr,"0x%x ", data[d]);
				}
			}
			fprintf(stderr,"\n");
        }
    }
}
